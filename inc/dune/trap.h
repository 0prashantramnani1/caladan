/*
 * trap.h - x86 exception and interrupt support
 */

#pragma once

#include <base/stddef.h>
#include <base/cpu.h>
#include <dune/mmu.h>

/* format used by LGDT and LIDT instructions */
struct tptr {
	uint16_t	limit;
	uint64_t	base;
} __packed;

/* the interrupt descriptor table (IDT) descriptor format */
struct idtd {
	uint16_t	low;
	uint16_t	selector;
	uint8_t		ist;
	uint8_t		type;
	uint16_t	middle;
	uint32_t	high;
	uint32_t	zero;
} __packed;

#define IDTD_P			(1 << 7)
#define IDTD_CPL3		(3 << 5)
#define IDTD_TRAP_GATE		0xF
#define IDTD_INTERRUPT_GATE	0xE

#define IDT_ENTRIES	256

/* the task-switch segment (TSS) descriptor format */
struct tssd {
	char		ign1[4];
	uint64_t	rsp[3];
	uint64_t	ist[8];
	char		ign2[10];
	uint16_t	iomb;
	uint8_t		iopb[];
} __packed;

/* x86 trap codes */
#define T_DIVIDE     0          // divide error
#define T_DEBUG      1          // debug exception
#define T_NMI        2          // non-maskable interrupt
#define T_BRKPT      3          // breakpoint
#define T_OFLOW      4          // overflow
#define T_BOUND      5          // bounds check
#define T_ILLOP      6          // illegal opcode
#define T_DEVICE     7          // device not available
#define T_DBLFLT     8          // double fault
/* #define T_COPROC  9 */       // reserved (not generated by recent processors)
#define T_TSS       10          // invalid task switch segment
#define T_SEGNP     11          // segment not present
#define T_STACK     12          // stack exception
#define T_GPFLT     13          // genernal protection fault
#define T_PGFLT     14          // page fault
/* #define T_RES    15 */       // reserved
#define T_FPERR     16          // floating point error
#define T_ALIGN     17          // aligment check
#define T_MCHK      18          // machine check
#define T_SIMDERR   19          // SIMD floating point error

/**
 * irq_disable - disables interrupts
 */
static inline void irq_disable(void)
{
	asm volatile("cli" : : : "memory");
}

/**
 * irq_enable - enables interrupts
 */
static inline void irq_enable(void)
{
	asm volatile("sti" : : : "memory");
}

/**
 * is_irq_enabled - are interrupts currently enabled?
 *
 * Returns true if interrupts are enabled.
 */
static inline bool is_irq_enabled(void)
{
	unsigned long flags;

	asm volatile("pushf\n\t"
		     "pop %0\n\t"
		     : "=rm" (flags) : : "memory");

	return ((flags & FL_IF) > 0);
}

/**
 * irq_save - disables interrupts, saving the current interrupt status
 *
 * Returns the current FLAGS.
 */
static inline unsigned long irq_save(void)
{
	unsigned long flags;

	asm volatile("pushf\n\t"
		     "pop %0\n\t"
		     : "=rm" (flags) : : "memory");

	if (flags & FL_IF)
		irq_disable();

	return flags;
}

/**
 * irq_restore - restores the previous interrupt status
 * @flags: the previous FLAGS
 */
static inline void irq_restore(unsigned long flags)
{
	asm volatile("push %0\n\t"
		     "popf\n\t"
		     : : "g" (flags) : "memory", "cc");
}

