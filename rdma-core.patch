diff --git a/providers/mlx5/dr_domain.c b/providers/mlx5/dr_domain.c
index 11af4589..ea99e301 100644
--- a/providers/mlx5/dr_domain.c
+++ b/providers/mlx5/dr_domain.c
@@ -188,9 +188,9 @@ static int dr_domain_caps_init(struct ibv_context *ctx,
 	if (ret)
 		return ret;
 
-	/* Non FDB type is supported only over root table */
-	if (dmn->type != MLX5DV_DR_DOMAIN_TYPE_FDB)
-		return 0;
+//	/* Non FDB type is supported only over root table */
+//	if (dmn->type != MLX5DV_DR_DOMAIN_TYPE_FDB)
+//		return 0;
 
 	ret = dr_devx_query_device(ctx, &dmn->info.caps);
 	if (ret)
diff --git a/providers/mlx5/dr_rule.c b/providers/mlx5/dr_rule.c
index 7a3bf633..3489ba64 100644
--- a/providers/mlx5/dr_rule.c
+++ b/providers/mlx5/dr_rule.c
@@ -32,6 +32,7 @@
 
 #include <stdlib.h>
 #include <ccan/minmax.h>
+#include "mlx5dv.h"
 #include "mlx5dv_dr.h"
 
 #define DR_RULE_MAX_STE_CHAIN (DR_RULE_MAX_STES + DR_ACTION_MAX_STES)
@@ -1294,6 +1295,32 @@ struct mlx5dv_dr_rule *mlx5dv_dr_rule_create(struct mlx5dv_dr_matcher *matcher,
 	return rule;
 }
 
+
+int switch_qp_action(struct mlx5dv_dr_rule *rule,
+	struct mlx5dv_dr_domain *dmn,
+	struct ibv_qp *nqp, struct ibv_qp *pqp)
+{
+	uint64_t old_qp_index, new_qp_index;
+	struct dr_ste *ste = &rule->rx.nic_matcher->s_htbl->ste_arr[0];
+	struct mlx5_qp *next_qp = to_mqp(nqp);
+	struct mlx5_qp *prev_qp = to_mqp(pqp);
+
+	assert(ste->htbl->chunk->num_of_entries == 1);
+
+	old_qp_index = DEVX_GET(ste_general, ste->hw_ste, next_table_base_39_32_size) << 27;
+	old_qp_index |= DEVX_GET(ste_general, ste->hw_ste, next_table_base_31_5_size);
+	old_qp_index &= ~0x1;
+
+	assert(old_qp_index == ((prev_qp->tir_icm_addr >> 5) & 0xffffffff));
+
+	new_qp_index = (next_qp->tir_icm_addr >> 5) | 1;
+	DEVX_SET(ste_general, ste->hw_ste, next_table_base_39_32_size, new_qp_index >> 27);
+	DEVX_SET(ste_general, ste->hw_ste, next_table_base_31_5_size, new_qp_index);
+
+	return dr_send_postsend_ste(dmn, ste, ste->hw_ste, DR_STE_SIZE_REDUCED, 0);
+}
+
+
 int mlx5dv_dr_rule_destroy(struct mlx5dv_dr_rule *rule)
 {
 	struct mlx5dv_dr_matcher *matcher = rule->matcher;
diff --git a/providers/mlx5/dr_send.c b/providers/mlx5/dr_send.c
index 64d892ea..11d04c30 100644
--- a/providers/mlx5/dr_send.c
+++ b/providers/mlx5/dr_send.c
@@ -39,7 +39,7 @@
 
 #define QUEUE_SIZE		128
 #define SIGNAL_PER_DIV_QUEUE	16
-#define TH_NUMS_TO_DRAIN	2
+#define TH_NUMS_TO_DRAIN	3
 
 enum {
 	CQ_OK = 0,
diff --git a/providers/mlx5/libmlx5.map b/providers/mlx5/libmlx5.map
index 1558e093..c5a147a1 100644
--- a/providers/mlx5/libmlx5.map
+++ b/providers/mlx5/libmlx5.map
@@ -105,4 +105,5 @@ MLX5_1.10 {
 		mlx5dv_dr_table_create;
 		mlx5dv_dr_table_destroy;
 		mlx5dv_qp_ex_from_ibv_qp_ex;
+		switch_qp_action;
 } MLX5_1.9;
diff --git a/providers/mlx5/mlx5dv.h b/providers/mlx5/mlx5dv.h
index 4e9c2733..8768601c 100644
--- a/providers/mlx5/mlx5dv.h
+++ b/providers/mlx5/mlx5dv.h
@@ -1416,6 +1416,10 @@ mlx5dv_dr_rule_create(struct mlx5dv_dr_matcher *matcher,
 		      size_t num_actions,
 		      struct mlx5dv_dr_action *actions[]);
 
+int switch_qp_action(struct mlx5dv_dr_rule *rule,
+	struct mlx5dv_dr_domain *dmn,
+	struct ibv_qp *nqp, struct ibv_qp *pqp);
+
 int mlx5dv_dr_rule_destroy(struct mlx5dv_dr_rule *rule);
 
 enum mlx5dv_dr_action_flags {
